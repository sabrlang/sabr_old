#true #-1 define ( -- b )
#false #0 define ( -- b )
#null #0 define ( -- addr )
#not { 0 = } define ( x -- b )
#and { ? swap ? & } define ( x1 x2 -- b )
#or { ? swap ? | } define ( x1 x2 -- b )
#select { if drop else nip end } define ( x1 x2 b -- x )

#++to { dup call ++ swap to } define ( id -- )
#--to { dup call -- swap to } define ( id -- )
#~to { dup call ~ swap to } define ( id -- )

#+to { dup call rot + swap to } define ( n id -- )
#-to { dup call rot - swap to } define ( n id -- )
#*to { dup call rot * swap to } define ( n id -- )
#/to { dup call rot / swap to } define ( n id -- )
#%to { dup call rot % swap to } define ( n id -- )
#f+to { dup call rot f+ swap to } define ( f id -- )
#f-to { dup call rot f- swap to } define ( f id -- )
#f*to { dup call rot f* swap to } define ( f id -- )
#f/to { dup call rot f/ swap to } define ( f id -- )
#f%to { dup call rot f% swap to } define ( f id -- )
#<<to { dup call rot << swap to } define ( x id -- )
#>>to { dup call rot >> swap to } define ( x id -- )
#&to { dup call rot & swap to } define ( x id -- )
#|to { dup call rot | swap to } define ( x id -- )
#^to { dup call rot ^ swap to } define ( x id -- )


#++store { dup fetch ++ swap store } define ( addr -- )
#--store { dup fetch -- swap store } define ( addr -- )
#~store { dup fetch ~ swap store } define ( addr -- )

#+store { dup fetch rot + swap store } define ( n addr -- )
#-store { dup fetch rot - swap store } define ( n addr -- )
#*store { dup fetch rot * swap store } define ( n addr -- )
#/store { dup fetch rot / swap store } define ( n addr -- )
#%store { dup fetch rot % swap store } define ( n addr -- )
#f+store { dup fetch rot f+ swap store } define ( f addr -- )
#f-store { dup fetch rot f- swap store } define ( f addr -- )
#f*store { dup fetch rot f* swap store } define ( f addr -- )
#f/store { dup fetch rot f/ swap store } define ( f addr -- )
#f%store { dup fetch rot f% swap store } define ( f addr -- )
#<<store { dup fetch rot << swap store } define ( x addr -- )
#>>store { dup fetch rot >> swap store } define ( x addr -- )
#&store { dup fetch rot & swap store } define ( x addr -- )
#|store { dup fetch rot | swap store } define ( x addr -- )
#^store { dup fetch rot ^ swap store } define ( x addr -- )

#cr { '\n' putc } define ( -- )
#space { ' ' putc } define ( -- )
#puts {
	loop dup 0 > while swap putc -- end drop
} define ( ... c u -- )
#putsln { puts cr } define ( ... c u -- )

#cells { 8 * } define ( u -- u )
#at { swap 8 * + } define ( u addr -- addr )
#new { cells alloc } define ( u -- )
#new? { new dup not if } define ( u -- addr )

#method {
	func $this to
} define ( id -- )

#for {
	trot tdup eval -- trot trot tdup #$ tswap concat eval to \ _start -- $var to
	loop
		tdup #$ tswap concat eval dup call ++ swap to \ $var dup call ++ swap to
		tdup eval tdrop tnip eval < \ _var _end <
	while
		\ code
} define ( #_start #_end #_var -- )

#-for {
	trot tdup eval ++ trot trot tdup #$ tswap concat eval to \ _start ++ $var to
	loop
		tdup #$ tswap concat eval dup call -- swap to \ $var dup call -- swap to
		tdup eval tdrop tnip eval > \ _var _end <
	while
		\ code
} define ( #_start #_end #_var -- )